package com.cof
package util

import Json._
import Misc._

import scala.reflect.runtime.universe.TypeTag
import akka.pattern.ask
import akka.actor.{ActorRef,ActorSystem}
import com.spingo.op_rabbit._
import com.spingo.op_rabbit.stream._
import Directives._
import com.thenewmotion.akka.rabbitmq._
import java.nio.charset.Charset

case class ObjMarshaller[T]()(implicit tag: TypeTag[T]) extends RabbitMarshaller[T] with RabbitUnmarshaller[T] {
	val contentType = "text/plain"
	private val encoding = "UTF-8"
	protected val contentEncoding = Some(encoding)
	private val utf8 = Charset.forName(encoding)

	def marshall(value: T) = Json.toJson(value).getBytes(utf8)
	def unmarshall(value: Array[Byte], contentType: Option[String], charset: Option[String]) = 
		Json.fromJson[T](new String(value, charset map (Charset.forName) getOrElse utf8))
}

object Rabbit {
	def declareQueues( names:List[String], rabbitControl:ActorRef )(implicit sys:ActorSystem) {
		val connectionActor = await((rabbitControl ? RabbitControl.GetConnectionActor).mapTo[ActorRef])
		val channelCreated  = await((connectionActor ? CreateChannel(ChannelActor.props(), None)).mapTo[ChannelCreated])
		names.foreach( name =>
			channelCreated.channel ! ChannelMessage { _.queueDeclare(name,true,false,false,null) }
			)
		sys.stop(channelCreated.channel)
	}

	def source[T](topicName:String, queueName:String, rabbitControl:ActorRef)(implicit um: RabbitUnmarshaller[T], system:ActorSystem) = {
		val binding = topic(queue(queueName, durable = true, exclusive = false, autoDelete = false), List(topicName))
		RabbitSource(
			rabbitControl,
			channel(qos = 3),
			consume(binding),
			body(as[T]))
	}
}